/**
* @file BpmEmulatorRpc.cpp
*
* This file is normally generated by Python (devsure/rpc).
* It contains the C/C++ API implementations for the RPC.
* Generated from the Python class BpmEmulatorRpc.
* Located in devsure/devsure/rpc/test/rpc_to_bpm_emu/bpm_emulator_rpc.py.
*/

#include "BpmEmulatorRpc.h"

#include <thread>
#include <memory>
#include <iostream>
#include <string>
#include <stdexcept>

namespace{

//communication channels
std::shared_ptr<InterfaceChannelRPC> ccalls_fwaits;
std::shared_ptr<InterfaceChannelRPC> cwaits_fcalls;

} //namespace



// __________________________________________________________________________
// API Proxy bodies (forward to Test Platform (framework) via connection)
InterruptInfo framework_wait_in_idle_state(){    
    uint16_t cpp_apiNumberForCallToOtherSide = 1;    
    ccalls_fwaits->Put(cpp_apiNumberForCallToOtherSide);
    
    ccalls_fwaits->Flush();    
    InterruptInfo cpp_obtained_result;    
    Deserialize(cpp_obtained_result, *ccalls_fwaits);    
    return cpp_obtained_result;
}

void framework_display_screen(char screen_bytes[460800]){    
    uint16_t cpp_apiNumberForCallToOtherSide = 2;    
    ccalls_fwaits->Put(cpp_apiNumberForCallToOtherSide);
    
    ccalls_fwaits->Put(screen_bytes, 460800);    
    ccalls_fwaits->Flush();
}



// ==========================================================================
namespace{
/// Generated API for receiving calls
void receiveRemoteCalls(){
    try{
        //TODO: need to check declaration checksum here
        uint16_t cpp_apiNumberArrivedFromFramework;
        for( ;; ){
            cwaits_fcalls->Get(cpp_apiNumberArrivedFromFramework);
            switch(cpp_apiNumberArrivedFromFramework){
            // __________________________________________________________________________
            // Stub bodies (receive from framework and call C/C++ implementations)

case 1:{    
    auto cpp_obtained_result = emulator_start_emulation();    
    cwaits_fcalls->Put(cpp_obtained_result);    
    cwaits_fcalls->Flush();
    break;
}

case 2:{    
    emulator_stop_emulation();
    break;
}

case 3:{    
    int32_t value;    

    
    cwaits_fcalls->Get(value);    
    auto cpp_obtained_result = emulator_echo(value);    
    cwaits_fcalls->Put(cpp_obtained_result);    
    cwaits_fcalls->Flush();
    break;
}



                default:{
                    //unknown API number
                    throw std::runtime_error("Unknown API number: "+std::to_string(cpp_apiNumberArrivedFromFramework));
                    return;
                } // default
            } // switch
        } // for
    }catch(const std::exception& e){
        std::cerr << "Exception in receiveRemoteCalls: " << e.what() << std::endl;
    }catch(...){
        std::cerr << "Unknown exception in receiveRemoteCalls" << std::endl;
    }
} // receiveRemoteCalls

} // namespace            
// ==========================================================================

// __________________________________________________________________________
// Serialization implementations

void Serialize(const InterruptInfo& self, InterfaceChannelRPC& channel) {
    // those that correspond to simple fields packed with struct.pack/.unpack
    channel.Put(self.time_ticks);
    channel.Put(self.pending_interrupts);
    channel.Put(self.pin_state);

    // those that correspond to nested fields serialized with their own methods
    ;
}
    
// __________________________________________________________________________
// Deserialization implementations

void Deserialize(InterruptInfo& self, InterfaceChannelRPC& channel) {
    // those that correspond to simple fields packed with struct.pack/.unpack
    channel.Get(self.time_ticks);
    channel.Get(self.pending_interrupts);
    channel.Get(self.pin_state);

    // those that correspond to nested fields deserialized with their own methods
    ;
}
    

// ==========================================================================
/// Setup actual RPC communication (called by Emulator startup code)
void SetupRPC_BpmEmulatorRpc(
    const std::shared_ptr<InterfaceChannelRPC>& ccalls_fwaits_toUse,
    const std::shared_ptr<InterfaceChannelRPC>& cwaits_fcalls_toUse,
    bool runAsynchronously
){
    ccalls_fwaits = ccalls_fwaits_toUse;
    cwaits_fcalls = cwaits_fcalls_toUse;

    if( runAsynchronously ){
        //Start the thread that will receive calls
        std::thread(receiveRemoteCalls).detach();
    }
    else{
        //Receive calls synchronously
        receiveRemoteCalls();
    }
}
